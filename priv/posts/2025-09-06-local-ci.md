---
title: "Rails 8.1’s Local CI: Lessons for Apple Developers"
description: "Rails 8.1 introduces local CI using developer machines instead of cloud pipelines. Could this work for Apple development? With deterministic builds and tools like Mise, it might save costs for small teams.​​​​​​​​​​​​​​​​"
tags: ["Tuist"]
---

I enjoy following the Ruby on Rails ecosystem because they constantly challenge assumptions with new ideas that help move their ecosystem forward. One such idea, which they had previously discussed and are finally making official with Rails 8.1, is using developers’ local environments as CI environments. Put simply, instead of pushing your changes for a CI provider to run pipelines and report status back, you run those steps locally and sign off on the commit.

When you first hear this idea, your brain likely rejects it because we’ve cargo-culted the concept of CI for many years and built numerous solutions upon that concept, like continuous releases through CI pipelines. But when you dig into the idea, you realize it actually makes sense in contexts where you can trust developers’ environments. This is the case, for example, in organizations built around trust (though not all organizations fit this model). However, it doesn’t work in open source contexts where you can’t trust everyone making external contributions.

As you can imagine, I couldn’t help but think about whether this would be sensible in the context of Apple development. After all, developers have the most foundational piece to enable this approach: powerful Apple Silicon machines for development. However, along with trust, these aren’t sufficient. One essential requirement is that we also need to trust environments and steps to be deterministic, and the workflows need to run fast.

Determinism is tricky today. Many Xcode projects compile not because they’re well-configured, but because dependencies are built in a certain order into derived data. Products accidentally succeed at linking when they should fail. If something fails, it should always fail. Period.

Apple is aware of this and is moving us away from that model with the new unified build system and their content-addressable store, which aims to solve two problems: first, non-determinism caused by derived data, and second, slow builds through remote storage solutions (where Tuist can provide low-latency caching close to where your developers are). We’re talking about probably a multi-year effort to make Apple’s system highly reliable, and for projects to migrate to it—since enabling it will likely mean breaking changes for them. But once we get there, we can assume determinism, and with Tuist integrated into your projects, we can achieve fast builds by sharing cache artifacts across environments.

Still, it’s not sufficient. Xcode builds and simulator processes aren’t hermetic. A script build phase might call a tool from the environment—SwiftGen, for example—or a test might pass only if some system tool is available (though this is rarer). SwiftPM helped make things somewhat more hermetic, but we’re not at Bazel’s level yet. So what can we do about that? DHH mentions this in his talk, and it’s something we’ve been strong proponents of: Mise. Mise is a frontend tool for managing dev environments and can play a key role in ensuring all environments are consistent. It doesn’t replace global environments entirely, but it gets us closer to an ideal world. For example, it can ensure everyone uses the same SwiftGen version instead of some random version installed by Homebrew.

I totally see this happening, which would help indie and small companies save significant money and reduce dependency on infrastructure and cloud providers. Developers have incredibly powerful machines that are underutilized most of the time, so they could leverage the cost they’ve already paid for those machines and go a long way before finally needing to introduce traditional CI.